# 07_multilevel.til
# TIL v2.0 - Multi-Level Programming
# Author: Alisher Beisembekov
#
# This example demonstrates TIL's unique multi-level system.
# Run: til run 07_multilevel.til

# ═══════════════════════════════════════════════════════════
# LEVEL 0: HARDWARE
# Maximum performance, always inlined
# Use for: inner loops, SIMD, math kernels
# ═══════════════════════════════════════════════════════════

#[level: 0]
fast_add(a: float, b: float) -> float
    return a + b

#[level: 0]
fast_multiply(a: float, b: float) -> float
    return a * b

#[level: 0]
fast_distance(x1: float, y1: float, x2: float, y2: float) -> float
    let dx = x2 - x1
    let dy = y2 - y1
    return sqrt(dx * dx + dy * dy)

# ═══════════════════════════════════════════════════════════
# LEVEL 1: SYSTEMS
# C-like control, inline hints
# Use for: performance-critical algorithms
# ═══════════════════════════════════════════════════════════

#[level: 1]
factorial(n: int) -> int
    var result = 1
    for i in 2..=n
        result *= i
    return result

#[level: 1]
is_prime(n: int) -> bool
    if n <= 1
        return false
    if n <= 3
        return true
    if n % 2 == 0
        return false
    var i = 3
    while i * i <= n
        if n % i == 0
            return false
        i += 2
    return true

# ═══════════════════════════════════════════════════════════
# LEVEL 2: SAFE (DEFAULT)
# Balanced performance and safety
# Use for: most application code
# ═══════════════════════════════════════════════════════════

struct Vector2D
    x: float
    y: float

impl Vector2D
    new(x: float, y: float) -> Vector2D
        return Vector2D { x: x, y: y }
    
    # Uses Level 0 for performance
    magnitude(self) -> float
        return fast_distance(0.0, 0.0, self.x, self.y)
    
    add(self, other: Vector2D) -> Vector2D
        return Vector2D.new(
            fast_add(self.x, other.x),
            fast_add(self.y, other.y)
        )
    
    scale(self, factor: float) -> Vector2D
        return Vector2D.new(
            fast_multiply(self.x, factor),
            fast_multiply(self.y, factor)
        )

# ═══════════════════════════════════════════════════════════
# LEVEL 3: SCRIPT
# Maximum productivity
# Use for: prototyping, scripts
# ═══════════════════════════════════════════════════════════

#[level: 3]
print_header(title: str)
    print("════════════════════════════════════")
    print(title)
    print("════════════════════════════════════")

#[level: 3]
demo_level_0()
    print_header("LEVEL 0: Hardware")
    print("fast_add(3, 4) =")
    print(fast_add(3.0, 4.0))
    print("fast_multiply(3, 4) =")
    print(fast_multiply(3.0, 4.0))
    print("fast_distance(0,0 to 3,4) =")
    print(fast_distance(0.0, 0.0, 3.0, 4.0))

#[level: 3]
demo_level_1()
    print_header("LEVEL 1: Systems")
    print("factorial(10) =")
    print(factorial(10))
    print("Primes up to 30:")
    for n in 2..=30
        if is_prime(n)
            print(n)

#[level: 3]
demo_level_2()
    print_header("LEVEL 2: Safe")
    let v1 = Vector2D.new(3.0, 4.0)
    let v2 = Vector2D.new(1.0, 2.0)
    print("v1 magnitude:")
    print(v1.magnitude())
    let v3 = v1.add(v2)
    print("v1 + v2:")
    print(v3.x)
    print(v3.y)

# ═══════════════════════════════════════════════════════════
# MAIN
# ═══════════════════════════════════════════════════════════

main()
    print("TIL v2.0 - Multi-Level Demo")
    print("Author: Alisher Beisembekov")
    print("")
    
    demo_level_0()
    print("")
    demo_level_1()
    print("")
    demo_level_2()
    print("")
    
    print_header("COMPLETE")
    print("All levels work together seamlessly!")
